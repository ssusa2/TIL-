<!-- @format -->

# **중간 정리(1)**

### Deep Dive **1장부터 10장**까지 정리한 내용을 다시.

<details>

  <summary>📝 목차</summary>

#### [1. 기본 개념과 동작 원리](./%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%9E%80%3F.md)

#### [2. 자바스크립트 개발 환경과 실행 방법](./%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD.md)

#### [3. 변수](./%EB%B3%80%EC%88%98.md)

#### [4. 표현식과 문](./%ED%91%9C%ED%98%84%EC%8B%9D%EA%B3%BC%20%EB%AC%B8.md)

#### [5. 데이터 타입](./%EB%8D%B0%EC%9D%B4%ED%84%B0%20%ED%83%80%EC%9E%85.md)

#### [6. 연산자](./%EC%97%B0%EC%82%B0%EC%9E%90.md)

#### [7. 제어문](./%EC%A0%9C%EC%96%B4%EB%AC%B8.md)

#### [8. 타입 변환과 단축 평가](./%ED%83%80%EC%9E%85%EB%B3%80%ED%99%98%EA%B3%BC%EB%8B%A8%EC%B6%95%ED%8F%89%EA%B0%80.md)

#### [9. 객체 리터럴](./%EA%B0%9D%EC%B2%B4%EB%A6%AC%ED%84%B0%EB%9F%B4.md)

#### [10. 원시값과객체의비교](./%EC%9B%90%EC%8B%9C%EA%B0%92%EA%B3%BC%EA%B0%9D%EC%B2%B4%EC%9D%98%EB%B9%84%EA%B5%90.md.md)

</details>

---

##### [1. 기본 개념과 동작 원리](./%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%9E%80%3F.md)

<br/>

**ECMA Script**
자바스크립트의 표준 사양

**자바스크립트 특징**

- 웹 브라우저에서 동작하는 유일한 프로그래밍 언어
- 개발자가 컴파일 작업을 수행하지 않는 인터프리터 언어
- 자바스크립트 명령형, 함수형, 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어

**컴파일러**
코드 전체를 변환 후, 실행

**인터프리터 언어**
코드 한 줄씩 변환 후, 실행

바벨과 같은 트랜스파일러를 사용해 ES6이상의 사양으로 구현된 코드를 ES5 이하의 사양으로 다운그레이드할 수 있다.

<br/>

---

##### [2. 자바스크립트 개발 환경과 실행 방법](./%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD.md)

<br/>

**브라우저**

HTML,CSS, JS를 실행해 웹페이지를 브라우저 화면에 렌더링하는 것이 주
목적이다.

HTML 요소를 선택하거나 조작하는 기능의 집합인 **DOM API** 제공

파일 생성 수정 시스템 제공하지 않는다.

**ECMAScript + 클라이언트 Web API**

**Node.js**

브라우저 외부에서 자바스크립트 실행환경을 제공하는 것이 주 목적이다.

Node.js 파일을 생성하고 수정할 수 잇는 파일 시스템 기본 제공

**ECMAScript + Node.js고유 API**

<br/>

---

##### [3. 변수](./%EB%B3%80%EC%88%98.md)

**리터럴** : 소스 코드의 고정된 값을 대표하는 용어

**연산자** : 주어진 식을 계산하여 결과를 얻어내는 과정 = 연산, 연산을 수행하는 기호 = 연산자

**피연산자** : 연산의 대상

<br/>

**메모리**

데이터를 저장할 수 있는 메모리 셀의 집합체
메모리 셀 하나의 크기 = 1바이트(8비트)

컴퓨터는 1바이트 단위로 데이터를 저장하거나 읽어들인다.

각 셀은 고유의 메모리 주소를 가짐.

메모리 주소는 메모리 공간의 위치를 나타낸다.
0부터 시작하여 메모리의 크기만큼 정수로 표현된다.

모든 데이터를 2진수로 처리.

자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다.

<br/>

**변수**

하나의 값을 저장하기 위해 붙인 이름

컴파일러 혹은 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행된다. => 변수를 통해 안전하게 값에 접근

여러 개의 값을 저장하는 방법 = 그룹화

변수에 값 저장 = 할당
읽어 들이는 것 = 참조

**변수 동작 원리**

1. 변수로 참조 요청
2. 변수이름과 매핑된 메모리 주소를 검색
3. 메모리에 접근 저장된 값 반환

<br/>

**식별자**

어떤 값을 구별해서 식별할 수 있는 고유한 이름

변수 뿐만 아니라 함수, 클래스 등의 모든 이름 식별자
네이밍 규칙 준수 = 선언에 의해 식별자의 존재를 알린다.

<br/>

**변수 선언**

변수를 생성

값을 저장하기 위해 메모리 공간을 확보, 변수 이름과 확보된 메모리 공간의 주소를 연결할 수 있게 준비하는 것

키워드 : 코드를 해석하고 실행되는 코드를 자바스크립트 엔진이 수행할 동작을 규정한 언어

**자바스크립트 엔진의 변수 선언 단계**

선언 단계 - 변수 이름 등록, 변수 존재 알림
초기화 단계 - 값을 저장하기 위한 메모리 공간 확보, undefined 할당 초기화

var 키워드를 사용한 변수 선언은 undefined 초기화 자동 수행, 선언단계와 초기화 단계 동시에 실행

<br/>

**변수 선언의 실행 시점과 변수 호이스팅**

변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점이 아니라 **그 이전 단계에 먼저 실행된다.**

실행 전 준비 단계에서 변수 선언을 포함한 선언문을 소스코드에서 찾아내 먼저 실행한다.

위와 같은 현상을 **변수 호이스팅**이라고 한다.

키워드를 사용해서 선언하는 모든 식별자는 호이스팅된다.
런타임 이전 단계에서 먼저 실행되기 때문이다.

<br/>

**값의 할당**

변수 값 할당 = 할당 연산자(=)

선언과 할당을 하나의 문으로 단축 표현할 수 있다.

하지만 선언과 할당의 실행 시점이 다르므로 주의하자.

선언은 런타임 이전에, 할당은 런타임 시점

<br/>

**값의 재할당**

값이 이미 할당되어 있는 변수에 새로운 값을 다시 할당하는 것

변수에 저장된 값을 변경할 수 없다면 변수가 아니라 **상수**

불필요한 값은 가비지 콜렉터에 의해 메모리에서 자동 해제된다.

언매니지드 언어와 매니지드 언어는 개발자가 메모리를 할당하고 해제할 수 있냐 없냐의 차이

<br/>

**const 키워드**

재할당 금지 된다. => 상수 표현 가능

<br/>

---

#### [4. 표현식과 문](./%ED%91%9C%ED%98%84%EC%8B%9D%EA%B3%BC%20%EB%AC%B8.md)

값 = 식이 평가되어 생성된 결과

평가란?

식을 해석해서 값을 생성하거나 참조하는 것을 의미함

모든 값은 데이터 타입을 가지고 메모리에 2진수(비트의 나열로 저장됨)

**리터럴**

사람이 이해할 수 있는 문자나 기호를 사용해 값을 생성하는 표기법

**표현식**

표현식은 다른 표현식의 일부가 되어 새로운 값을 만들어낼 수 있다.

**문**

프로그램을 구성하는 기본 단위이자 최소실행 단위 문의 집합

여러 토큰으로 구성된다.

토큰?

문법적인 의미를 가지고 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미함

**표현식과 문을 구별하는 방법**

변수를 할당해보자!

표현식인 문은 값으로 평가되므로 변수에 할당할 수 있다.

표현식이 아닌 문은 값으로 평가될 수 없다. = 에러 발생

<br/>

---

##### [5. 데이터 타입](./%EB%8D%B0%EC%9D%B4%ED%84%B0%20%ED%83%80%EC%9E%85.md)

데이터 타입 = 값의 종류

원시 타입과 객체 타입으로 분류됨

원시 타입은 6개 객체 타입을 제외한 모든 타입이 포함되어 있다.

#### **숫자 타입**

배정밀도 64비트 부동소수점 형식을 따름 => 모든 수를 실수로 처린

2진수로 저장됨 => 참조시 10진수로 해석

`Infinity` 양의 무한대
`-Infinity` 음의 무한대
`NaN` 산술 연산 불가

<br/>

#### **문자열 타입**

텍스트 데이터를 나타냄

**템플릿 리터럴**
런타임에 일반 문자열로 변환되어 처리됨

**표현식 삽입**
템플릿 리터럴에서는 간단하게 문자열을 삽입할 수 있다.

**${}** 으로 감싸 표현식을 삽입할 수 있다.

<br/>

#### **불리언 타입**

참과 거짓을 나타내는

조건에 의해 프로그램의 흐름을 제어할 때 사용

<br/>

#### **undefinde 타입**

자바스크립트 엔진이 변수를 초기화할 때 사용.

변수에 값이 없다는 것을 명시하고 싶을 때 => null 할당

##### 선언과 정의 : 변수는 선언한다. 함수는 정의한다. 로 표현함

<br/>

#### **심벌 타입**

원시 타입 다른 값과 중복되지 않은 유일무이 한 값
(충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 위해 사용)

Symbol 함수를 호출해 생성

<br/>

**객체 타입**

**데이터 타입에 의한 메모리 공간의 확보와 참조**

값은 메모리에 저장하고 참조할 수 있어야 한다.

**동작 순서**

1. 값을 저장하기 위해 메모리 공간을 확보한다.
2. 확보한 메모리에 값을 저장한다.

값의 종류에 따라 정해진 크기에 메모리 공간을 확보한다.

한 번에 읽어들어야 하는 메모리 공간의 크기 = 바이트 수

타입마다 값이 할당되어 있어 타입을 인식하고 타입에 따라 메모리 셀의 크기를 알 수 있다.

##### 심벌 테이블 : 컴파일러, 인터프리터는 심벌테이블이라고 하는 자료 구조를 통해 식별자를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리한다.

<br/>

**데이터 타입에 의한 값의 해석**

값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해

한 번에 읽어들어야 할 메모리 공간의 크기를 결정하기 위해

2진수를 어떻게 해석할지 결정하기 위해

<br/>

**동적 타이핑**

동적 타입 언어와 정적 타입 언어

다른 언어는 변수를 선언할 때 데이터 타입을 선언해야 한다.
하지만 자바스크립트는 변수의 할당된 값의 데이터 타입을 반환하는 것이다.
선언이 아닌 할당에 의해 타입이 결정된다. 이러한 특징을 동적 타이핑이라고 한다. => 동적 타입 언어

유연하지만 신뢰성이 떨어진다.

- 최대한 제한적으로 사용
- 변수의 유효 범위를 좁게
- 전역 변수 자제
- 상수를 사용해 변경 억제
- 목적과 의미를 알 수 있는 네이밍

<br/>

---

#### [6. 연산자](./%EC%97%B0%EC%82%B0%EC%9E%90.md)

하나 이상의 표현식을 대상으로 연산을 수행해야 하나의 값을 만든다.

연산의 대상을 피연산자

피연산자 = 값으로 평가될 수 있는 표현식이어야 함

연산자 표현식 = 피연산자 + 연산자 = 값으로 평가될 수 있는 표현식

증가 / 감소 연산자는 위치에 의미가 있다.

피연산자 앞 = 값을 증감시킨 후, 다른 연산 수행
피연산자 뒤 = 다른 연산 수행 후, 값을 증감

+단항 연산자는 숫자타입으로 값을 변환한다.

-단항 연산자는 부호를 반전합 값을 반환한다. 숫자타입으로 변환하여 반환한다.

연산자의 **부수 효과**에 대해 주의하자.

연산자는 **우선 순위**가 존재한다. 가장 높은 그룹 연산자를 사용하여 우선순위를 명시적으로 조절하자.

**연산자의 결합 순서**

연산자의 어느 쪽부터 평가를 수행할 것인지를 나타내는 순서를 말한다.

<br/>

---

#### [7. 제어문](./%EC%A0%9C%EC%96%B4%EB%AC%B8.md)

조건에 따라 코드 블럭을 실행하거나 반복 실행할 때 사용한다.

제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다.

**블록문**

0개 이상의 문을 중괄호로 묶은 것

**조건문**

불리언 값으로 평가될 수 있는 표현식

##### **if...else문**

논리적 참 또는 거짓에 따라 실행할 코드 블럭을 결정한다.

if문과 else문은 2번 이상 사용할 수 없지만 if...else문은 여러 번 사용가능하다. 하지만 조건이 간단하다면 삼항 조건 연산자로 바꿔서 사용할 수 있다.

```js
조건 ? 조건값이 true일 때, 실행할 코드 : 조건값이 false일 때, 실행할 코드
```

##### **switch문**

표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 흐름을 옮긴다.

일치하는 case문이 없다면 실행 순서는 default 문으로 이동한다. (default는 선택 사항)

<br/>

### **반복문**

조건식이 거짓일 때까지 반복한다.

**for문**

**while문**
평가 결과가 참이면 계속 반복 실행
거짓이면 종료

탈출하려면 if문안에 break문으로 탈출

### **for문은 반복횟수가 명확할 때, while은 반복 횟수가 불명확할 때 사용**

<br/>

**do... while문**
코드 블록을 먼저 실행하고 조건식을 평가한. 무조건 한 번 이상은 실행됨

**continue문**
실행 흐름을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다.

<br/>

---

#### [8. 타입 변환과 단축 평가](./%ED%83%80%EC%9E%85%EB%B3%80%ED%99%98%EA%B3%BC%EB%8B%A8%EC%B6%95%ED%8F%89%EA%B0%80.md)

값의 타입은 개발자의 의도에 따라 다른 타입으로 변환할 수 있다.

**개발자의 의도가 있다면?**
=> 명시적 타입 변환, 타입 캐스팅

**개발자의 의도가 없다면?** =>
암묵적 타입 변환, 타입 강제 변환

위처럼 개발자가 의도하지 않았음에도 불구하고 타입 변환이 일어날 수 있기에 코드를 예측하여 오류를 사전에 방지하고 흐름을 읽을 수 있어야 한다.

### **암묵적 타입 변환**

<br/>

**문자열 타입으로 변환**

문자열, 숫자, 불리언과 같은 원시 타입 중 하나로 타입을 자동 변환한다.

문자열 연결 연산자의 모든 피연산자는 코드의 문맥상 모두 문자열 타입이어야 한다.

따라서 문자열 타입이 아닌 값에 +(문자열 연결 연산자)를 사용하면 문자열로 강제 변환된다.

<br/>

**숫자 타입으로 변환**

산술 연산자를 통해 숫자 값을 만든다. 따라서 코드 문맥상 모두 숫자 타입이어야 한다.

숫자 타입이 아닌 피연산자를 숫자 타입으로 강제 변환한다.

<br/>

**불리언 타입으로 변환**

자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값 또는 Falsy 값으로 구분한다.

따라서, 불리언 값으로 평가되어야 할 문맥에서 Truthy 값은 true로 / Falsy 값은 false한 값으로 암묵적 타입 변환된다.

<br/>

### **명시적 타입 변환**

<br/>

**문자열 타입으로 변환**

1. String 생성자를 new 연산자 없이 호출
2. Object.prototype.toString 메서드를 사용하는 방법
3. 문자열 연결 연산자를 이용하는 방법

<br/>

**숫자 타입으로 변환**

1. Number 생성자를 new 연산자 없이 호출
2. parseInt.parseFloat 함수를 사용(문자열만 가능)
3. +단항 산술 연산자
4. \*산술 연산자

<br/>

**불리언 타입으로 변환**

1. Boolean 생성자 함수를 new 없이 호출
2. ! 부정 논리 연산자를 두 번 사용

<br/>

### **단축 평가**

논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환하는 것.

=> 표현식을 평가하는 과정에서 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것

**논리합 || 연산자**

좌항 값이 true면 좌항 값을 (우항 값을 평가하지 않는다.)

<br/>

**논리곱 && 연산자**

좌항 값이 true여도 우항 값이 true여야 성립되기 때문에 우항 값을!

반대로 좌항 값이 false면 좌항 값을

<br/>

단축평가를 사용하면 참조하는 변수의 값이 null이나 undefined인 경우에도 오류를 일으키지 않는다.

**|| 논리합 연산자를 통해 기본 값을 설정할 수 있다.**

<br/>

#### **옵셔녈 체이닝 연산자 ?.**

좌항의 피연산자가 null이나 undefined인 경우 undefined를 반환하고 그렇지 않으면 우항의 프로퍼티 참조를 이어나간다.

오류를 일으키지 않아서 유용하다.

<br/>

#### **null 병합 연산자**

좌항의 피연산자가 null이나 undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.

변수에 기본값을 설정할 때 유용하다.

### **||** 와 **??** 의 차이점

||는 좌항이 Falsy한 값이라도 우항의 값을 반환했다.

??는 좌항이 Falsy한 값이라도 null 이나 undefined가 아니라면 좌항을 반환한다.

```js
var foo = '' || 'default';
console.log(foo); // 'default'

var foo = '' ?? 'default';
console.log(foo); // ''
```

<br/>

---

#### [9. 객체 리터럴](./%EA%B0%9D%EC%B2%B4%EB%A6%AC%ED%84%B0%EB%9F%B4.md)

객체는 프로퍼티와 메서드로 구성된 집합체이다.

**프로퍼티는 객체의 상태를 나타내고, 메서드는 객체의 상태를 참조하고 조작하는 동작이다.**

<br/>

**인스턴스**

클래스에 의해 생성되어 메모리에 저장된 실체를 말한다.

<br/>

- **객체 리터럴에 의한 객체 생성**

사람이 이해할수 있게 표현하는 법

중괄호 안에 프로퍼티를 정의한다.

<br/>

**프로퍼티**

객체는 프로퍼티의 집합이며 프로퍼티는 **키와 값으로 구성**된다.

나열할때는 쉼표로 구분

프로퍼티 키는 값에 접근할 수 있는 이름으로서 식별자 역할을 한다.

반드시 네이밍 규칙을 따라야 하며, 따르지 않는 경우는 ""따옴표를 반드시 사용해야 한다.

동적으로 프로퍼티 키를 생성할 수 있다. 이경우는 대괄호[]로 묶어서 사용해야 한다.

이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다.

<br/>

**메서드**

함수는 객체다.

함수는 값으로 취급할 수 있기에 프로퍼티의 값으로 사용할 수 있다.

프로퍼티 값이 함수일 경우에 일반 함수와 구분하기 위해 메서드라 부른다.

**프로퍼티 접근**

- 마침표 표기법
- 대괄호 표기법
  내부에 저장하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다.

<br/>

**프로퍼티 동적 생성**

프로퍼티에 값을 할당하면 동적으로 생성되어 값이 할당된다.

<br/>

**프로퍼티 삭제**

delete 연산자를 통해 삭제할 수 있다.

<br/>

**ES6 추가 문법**

- 프로퍼티의 키와 값이 같다면 키를 생략할 수 있다.
- 객체 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성할 수 있다.

<br/>

#### [10. 원시값과객체의비교](./%EC%9B%90%EC%8B%9C%EA%B0%92%EA%B3%BC%EA%B0%9D%EC%B2%B4%EC%9D%98%EB%B9%84%EA%B5%90.md.md)

**데이터 타입을 구분하는 이유는 근본적으로 다르기 때문**

원시 타입은 값의 변경이 불가능하고, 원시 값을 변수에 할당하면 실제 값이 저장된다. 값에 의한 전달이 이루어진다.

객체 타입은 값의 변경이 가능하며, 객체 값을 변수에 할당하면 참조 값이 저장된다. 참조에 의한 전달이 이루어진다.

<br/>

**원시 값**

원시 값은 어떤 일이 있어도 불변한다. 이러한 특성은 데이터의 신뢰성을 보장한다.

원시 값을 할당한 변수에 새로운 원시 값을 재할당하면 메모리 공간에 저장되어 있는 원시 값을 변경하는 것이 아니다.
새로운 메모리 공간을 확보하고 원시 값을 저장한 후, 새로운 원시 값을 가리킨다.

이때, 변수가 참조하던 메모리 공간의 주소가 바뀐다.

**문자열과 불변성**

원시 값을 저장하려면 먼저 확보해야 하는 메모리 공간의 크기를 결정해야 한다.
숫자와 다르게 문자열은 몇 개의 문자로 이루어져 있냐에 따라 필요한 메모리 공간의 크기를 결정한다.

**값에 의한 전달**

값에 의한 전달은 값을 전달하는 것이 아니라 메모리 주소를 전달한다.

때문에 중요한 것은 두 변수 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다.

<br/>

**객체**

객체의 프로퍼티는 동적으로 추가되며 삭제할 수 있다.

프로퍼티 키를 인덱스로 사용하는 해시 테이블이라고 생각할 수 있다.

**변경 가능한 값**

원시 값을 할당한 변수는 원시 값 자체를 값으로 가짐

참조 값은 생성된 객체가 저장된 메모리 공간의 주소 그 자체다.

객체를 할당한 변수에는 생성된 객체가 실제로 저장된 공간의 주소가 저장되어 있다 => **참조값**

하지만 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 단점이 존재한다.

**참조에 의한 전달**

객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. => 참조에 의한 전달

두 개의 식별자가 하나의 객체를 공유한다는 것을 의미한다. 원본 또는 사본 중 어느 한쪽에서 객체 값을 변경한다면 서로 영향을 주고 받는다.

값에 의한 전달과 참조에 의한 전달은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달하는 면에서 동일하다.

그 차이는 변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이만 있을 뿐이다.

따라서 자바스크립트는 참조에 의한 전달은 존재하지 않고 값에 의한 전달만 존재한다고 말할 수 있다.
