<!-- @format -->

## **데이터 타입**

**값의 종류**를 말한다.
ES6에서는 7개의 데이터 타입을 제공한다.

**원시 타입**과 **객체 타입**으로 분류된다.

---

### **원시타입**

숫자 : 숫자, 정수와 실수 구분 없음

문자열 : 문자열

불리언 : 논리적 참과 거짓

undefined : var 키워드로 선언된 변수에 암묵적으로 할당되는 값

null : 값이 없다는 것을 의도적으로 명시할 때 사용하는 값

심벌 : ES6에서 새로 추가된 값

### **객체타입**

객체, 함수, 배열 등

---

문자열 타입 "1"과 숫자 타입 1의 값은 다른 값이다.
확보해야할 메모리 공간의 크기도 다르고 2진수, 해석하는 방법 또한 다 다르다.

때문에 개발자가 명확한 의도를 가지고 타입을 구별해서 값을 생성하고, 자바스크립트 엔진은 타입을 구별해서 값을 취급할 것이다.

<br/>

---

## **숫자 타입**

다른 언어와는 다르게 자바스크립트는 숫자 타입이 단 하나만 존재한다.

배정밀도 64비트 부동소수점 형식을 따른다. 즉, 모든 수를 실수로 처리한다.

```js
var integer = 10; // 정수
var double = 10.2; // 실수
var negative = -20; // 음의 정수
// 모두 숫자 타입이다.
```

모두 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다.
따라서 2진수, 8진수, 16진수를 표한하기 위한 데이터 타입을 제공하지 않기 때문에 이들 값을 참조하면 **모두 10진수로 해석**한다.

```js
var binary = 0b01000001; // 2진수
var octal = 0o101; // 8진수
var hex = 0x41; // 16진수
// 모두 65로 같은 값이다.
```

```js
console.log(1 === 1.0); // true
console.log(4 / 2); // 2
```

**숫자 타입의 세 가지 특별한 값**

**Infinity** : 양의 무한대

**-Infinity** : 음의 무한대

**NaN** : 산술 연산 불가 (not-a-number)

```js
console.log(10 / 0); // Infinity
console.log(10 / -0); // -Infinity
console.log(1 * 'string'); // NaN
```

<br/>

---

## **문자열 타입**

텍스트 데이터를 나타내는 데 사용
0개 이상의 16비트 유니코드 문자의 집합

문자열은 작은따옴표, 큰따옴표, 백틱으로 텍스트를 감싼다. 주로 작은따옴표를 사용

문자열을 따옴표로 감싸는 이유는 문자열의 내용을 다른 식별자나 키워드 같은 토큰으로 인식하기 때문이다.

따옴표로 감싸지 않는다면 스페이스와 같은 **공백 문자를 포함시킬 수 없다.**

<br/>

---

## **템플릿 리터럴**

ES6부터 새로운 문자열 표기법이 도입되었다.
문자열, 표현식 삽입. 태그드 템플릿 등의 기능이 추가됨
**런타임에 일반 문자열로 변환되어 처리됨**

### **멀티라인 문자열**

일반 문자열 내에서는 줄바꿈이 허용되지 않는다.
따라서 줄바꿈을 표현하면 공백을 뜻하는 \로 시작하는 이스케이프 시퀀스를 사용해야 한다. 주로 **\n**

하지만 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않아도 줄바꿈이 허용되고, 모든 공백이 있는 그대로 적용된다.

```js
var templete = `<ul>
    <li><a href="#">Home</a></li>
  </ul>`;

console.log(templete);
// <ul>
// 	<li>
// 		<a href='#'>Home</a>
// 	</li>
// </ul>;
```

<br/>

---

### **표현식 삽입**

문자열은 문자열 연산자 +를 사용해 연결할 수 있다. +연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작하고 그 외의 경우는 덧셈 연산자로 동작함.

```js
var first = 'Suin';
var last = 'Jeong';

console.log('My name is ' + first + ' ' + last + '!'); // 'My name is Suin Jeong!'
```

템플릿 리터럴 내에서는 표현식 삽입을 통해 간단하게 문자열을 삽할 수 있다.

```js
var first = 'Suin';
var last = 'Jeong';

console.log(`My name is ${first} ${last} !`); //'My name is Suin Jeong !'
```

표현식을 삽입하려면 **${}** 으로 감싼다.

<br/>

---

## **불리언 타입**

값은 참과 거짓을 나타내는 true, false 둘 뿐이다.

조건에 의해 프로그램의 흐름을 제어하는 조건문에서 자주 사용

```js
var foo = true;
console.log(foo); //true

foo = false;
console.log(foo); //false
```

<br/>

---

## **undefined 타입**

값은 undefined가 유일하다.

undefined 값은 자바스크립트 에진이 변수를 초기화할 때 사용하는 값이다. 즉 변수를 참조했을 때, undefined가 반환된다면 참조한 변수가 선언 이후 값이 할당된 적이 없는, 초기화되지 않은 변수라는 것을 간파할 수 있다.

#### **변수에 값이 없다는 것을 명시하고 싶을 때는 어떻게 하면 좋을까?**

=> **null를 할당**한다.

<br/>

##### **선언과 정의** : 변수는 선언한다. 함수는 정의한다. 로 표현함

<br/>

---

## **null 타입**

null 타입도 null 값이 유일하다.
자바스크립트도 대소문자를 구별하므로 조심하자.

null은 변수에 값이 없다는 것을 의도적으로 명시할 때 사용된다.

변수에 **null을 할당하는 것**은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미다.
이는 **이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거**하는 것을 의미.
=> 자바스크립트 엔진이 카비지 콜렉션을 수행할 것

<br/>

---

## **심벌 타입**

ES6에서 추가된 7번째 타입, 변경 불가능한 원시 타입
**다른 값과 중복되지 않는 유일무이한 값**
주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.

**Symbol함수를 호출해 생성**
생성된 심벌값은 외부에 노출되지 않으며, 다른 값과 절대 중복되지 않는 유일무이한 값이다.

```js
//심벌 값 생성
var key = Symbol('key');
console.log(typeof key); // symbol

//객체 생성
var obj = {};

// 이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용한다.
obj[key] = 'value';
console.log(obj[key]); //value
```

<br/>

---

## **객체 타입**

자바스크립트의 데이터 타입은 원시 타입과 객체 타입으로 분류된다.

그 이유는 원시 타입과 객체 타입이 근본적으로 다름을 의미한다. 이는 추후
[11장 원시값과 객체의 비교](./%EC%9B%90%EC%8B%9C%20%EA%B0%92%EA%B3%BC%20%EA%B0%9D%EC%B2%B4%EC%9D%98%20%EB%B9%84%EA%B5%90.md)
에서 자세히 살펴보자.

<br/>

---

## **데이터 타입의 필요성**

<br/>

### **데이터 타입에 의한 메모리 공간의 확보와 참조**

값은 메모리에 저장하고 참조할 수 있어야 한다.
값을 저장하려면 먼저 확보해야 할 메모리 공간의 크기를 결정해야 한다.

```js
var score = 100;
```

위 코드를 실행했을 때 동작순서

1. 컴퓨터는 숫자 값 100을 저장하기 위해 메모리 공간을 확보한다.
2. 확보된 메모리에 숫자 값 100을 2진수로 저장한다.

위와 같이 동작하려면 숫자 값을 저장할 때 확보해야 할 메모리 공간의 크기를 알아야 한다.

자바스크립트 엔진은 데이터 타입, 즉 **값의 종류에 따라 정해진 크기의 메모리 공간을 확보**한다.

**값을 참조하는 경우**
식별자 score을 통해 숫자 타입의 값 100이 저장되어 있는 메모리 공간의 주소를 찾아갈 수 있다.

이때 **한 번에 읽어 들여야 할 메모리 공간의 크기**. 즉 **바이트 수**를 알아야 한다.

score 변수의 경우, 숫자 타입이므로 8바이트 단위로 읽어 들이지 않으면 값이 훼손된다.

#### 한 번에 읽어 들여야 할 메모리 셀의 크기를 어떻게 알 수 있을까?

변수에는 **숫자 타입의 값이 할당되어 있으므로** 자바스크립트 엔진이 변수 score을 **숫자 타입으로 인식**한다.

숫자 타입은 8바이트 단위로 저장되므로 변수를 참조하면 8바이트 단위로 저장된 값을 읽어 들인다.

##### **심벌 테이블** : 컴파일러, 인터프리터는 심벌테이블이라고 하는 자료 구조를 통해 식별자를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리한다.

<br/>

### **데이터 타입에 의한 값의 해석**

메모리에서 읽어 들인 2진수를 어떻게 해석할까?

모든 값은 데이터 타입을 가지며, 메모리에 2진수, 즉 비트의 나열로 저장된다. 메모리에 저장된 값은 데이터타입에 따라 다르게 해석된다.

score 변수에 할당된 값은 숫자 타입이다.
따라서 변수를 참조하면 메모리 공간의 주소에서 읽어들인 2진수를 숫자로 해석한다.

**데이터 타입이 필요한 이유**

- 값을 저장할 때 **확보해야 하는 메모리 공간의 크기를 결정**하기 위해
- 값을 참조할 때 **한 번에 읽어 들여야 할 메모리 공간의 크기를 결정**하기 위해
- 메모리에서 읽어들인 **2진수를 어떻게 해석**할지 결정하기 위해

<br/>

## **동적 타이핑**

<br/>

### **동적 타입 언어와 정적 타입 언어**

모든 값은 데이터 타입을 가진다.

**변수는 데이터 타입을 가질까?**

다른 정적인 언어는 변수를 선언할 때, 데이터 타입을 사전에 선언해야 한다. 이를 명시적 타입 선언이라고 한다.

정적 타입 언어는 변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있다.
컴파일 시점에 **타입 체크**를 수행하고 만약 통과되지 않았다면 에러를 발생시키고 프로그램의 실행 자체를 막는다.
이를 통해 타입의 일관성을 강제하여 더욱 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 막는다.

자바스크립트는 변수를 선언할 때 타입을 선언하지 않는다.
**자바스크립트는 변수의 데이터 타입을 반환하는 것이 아니라 변수의 할당된 값의 데이터 타입을 반환하는 것**이다.

자바스크립트의 변수는 **선언이 아닌 할당에 의해 타입이 결정**된다.
또한, 재할당에 의해 변수의 타입은 언제든지 동적으로 변경될 수 있다. 이러한 특징을 **동적 타이핑**이라고 한다.

자바스크립트는 정적 타입 언어와 구별하기 위해 **동적 타입 언어**라고 한다.

<br/>

### **동적 타입 언어와 변수**

변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있다.
데이터 타입에 대해 너무나 편리하지만, 이는 양날의 검이 될 수 있다.
변수 값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변수 값을 추적하기 어려울 수 있다.

이처럼 동적 타입 언어는 유연하지만 신뢰성이 떨어진다.

**변수를 사용할 때 주의사항**

- 꼭 필요한 경우에 한해 제한적으로 사용하자.
- 변수의 유효 범위는 최대한 좁게 만들어 변수의 부작용을 억제해야한다.
- 전역 변수는 최대한 사용하지 않도록 한다.
- 변수 보다는 상수를 사용해 값의 변경을 억제한다.
- 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다.

### **좋은 코드?**

사람이 이해할 수 있는, 가독성이 좋은 코드가 좋은 코드다.
훌륭한 프로그래머는 사람이 이해할 수 있는 코드를 쓴다.
