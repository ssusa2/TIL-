<!-- @format -->

# **자료구조**

<br/>

## **선형구조**

한 원소 뒤에 하나의 원소만 존재하는 형태

<br/>

## **비선형구조**

원소가 여러개의 원소와 관계를 띄는 형태

<br/>

---

<br/>

# **시간복잡도**

<br/>

## **빅오표기법**

대략적인 성능을 비교하기 위한 상대적인 표기법

### **1. 계수 법칙**

n이 무한에 가까울 수록 k의 크기는 의미가 없다.

```js
// 두 루프는 같은 O(n)으로 표기된다.
for (let i = 0; i < n; i += 1) {
	// ...
}
```

### **2. 합의 법칙**

빅오는 더해질 수 있다.

```js
// 두 루프를 합쳐 O(n + m)으로 표기할 수 있다.
// 계수 법칙에 의해 5는 사라진다.
for (let i = 0; i < n; i += 1) {
	// ...
}

for (let i = 0; i < m * 5; i += 1) {
	// ...
}
```

### **3. 곱의 법칙**

빅오는 곱해질 수 있다.

```js
// 두 루프를 곱해 O(n^2)으로 표기할 수 있다.
// 계수 법칙에 의해 5는 사라진다.
for (let i = 0; i < n; i += 1) {
	for (let j = 0; j < n * 5; j += 1) {
		// ...
	}
}
```

### **4. 다항 법칙**

```js
// 다음 루프는 O(n^3)으로 표기할 수 있다.
for (let i = 0; i < n * n * n;; i += 1) {
	// ...
}
```

## 상수항은 무시,

```js
// 계수 법칙에 의해 계수는 무시된다.
// 그리하여 O(n + m)으로 표기된다.
for (let i = 0; i < n * 6; i += 1) {
	// ...
}

for (let i = 0; i < m * 3; i += 1) {
	// ...
}
```

## 가장 큰 항 외엔 무시

```js
// O(n^2 + n)이지만 작은 항은 무시하여
// O(n^2)으로만 표기해도 된다.
for (let i = 0; i < n; i += 1) {
	// ...
}

for (let i = 0; i < n; i += 1) {
	for (let j = 0; j < n; j += 1) {}
	// ...
}
```

<br/>

### **선형시간 O(n)**

```js
for (let i = 0; i < n; i += 1) {
	// ...
}
```

### **로그시간 O(log n)**

```js
for (let i = 0; i <= n; i *= 2) {
	// ...
}
```

### **선형지수 O(n log n)**

```js
for (let i = 0; i < n; i += 1) {
	for (let j = 1; j <= n; j *= 2) {
		// ...
	}
}
```

### **2차시간 O(n log n)**

```js
for (let i = 0; i < n; i += 1) {
	for (let j = 0; j < n; j += 1) {
		// ...
	}
}
```

<br/>

---

<br/>

# **성능측정방법**

Date 객체를 이용

```js
const start = new Date().getTime();

// ...

const end = new Date().getTime();
console.log(end - start);
```
